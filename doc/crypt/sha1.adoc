////
Copyright 2024 Matt Borland
Distributed under the Boost Software License, Version 1.0.
https://www.boost.org/LICENSE_1_0.txt
////

[#sha1]
:idprefix: sha1_

= SHA1

This library supports SHA1 as described in https://datatracker.ietf.org/doc/html/rfc3174[RFC 3174].
There is a wide range of acceptable inputs for the base sha1 function:

== Hashing Functions

[source, c++]
----
namespace boost {
namespace crypt {

uisng return_type = boost::crypt::array<uint8_t, 20>;

BOOST_CRYPT_GPU_ENABLED inline auto sha1(const char* str) noexcept -> return_type;

BOOST_CRYPT_GPU_ENABLED inline auto sha1(const char* str, size_t len) noexcept -> return_type;

BOOST_CRYPT_GPU_ENABLED inline auto sha1(const unsigned char* str) noexcept -> return_type;

BOOST_CRYPT_GPU_ENABLED inline auto sha1(const unsigned char* str, size_t len) noexcept -> return_type;

BOOST_CRYPT_GPU_ENABLED inline auto sha1(const char16_t* str) noexcept -> return_type;

BOOST_CRYPT_GPU_ENABLED inline auto sha1(const char16_t* str, size_t len) noexcept -> return_type;

BOOST_CRYPT_GPU_ENABLED inline auto sha1(const char32_t* str) noexcept -> return_type;

BOOST_CRYPT_GPU_ENABLED inline auto sha1(const char32_t* str, size_t len) noexcept -> return_type;

BOOST_CRYPT_GPU_ENABLED inline auto sha1(const wchar_t* str) noexcept -> return_type;

BOOST_CRYPT_GPU_ENABLED inline auto sha1(const wchar_t* str, size_t len) noexcept -> return_type;

inline auto sha1(const std::string& str) noexcept -> return_type;

inline auto sha1(const std::u16string& str) noexcept -> return_type;

inline auto sha1(const std::u32string& str) noexcept -> return_type;

inline auto sha1(const std::wstring& str) noexcept -> return_type;

#ifdef BOOST_CRYPT_HAS_STRING_VIEW

inline auto sha1(std::string_view str) noexcept -> return_type;

inline auto sha1(std::u16string_view str) noexcept -> return_type;

inline auto sha1(std::u32string_view str) noexcept -> return_type;

inline auto sha1(std::wstring_view str) noexcept -> return_type;

#endif // BOOST_CRYPT_HAS_STRING_VIEW

#ifdef BOOST_CRYPT_HAS_SPAN

template <typename T, std::size_t extent>
inline auto md5(std::span<T, extent> data) noexcept -> return_type;

#endif // BOOST_CRYPT_HAS_SPAN

#ifdef BOOST_CRYPT_HAS_CUDA

template <typename T, boost::crypt::size_t extent>
BOOST_CRYPT_GPU_ENABLED inline auto md5(cuda::std::span<T, extent> data) noexcept -> return_type;

#endif // BOOST_CRYPT_HAS_CUDA

} //namespace crypt
} //namespace boost
----

== File Hashing Functions

We also have the ability to scan files and return the sha1 value:

[source, c++]
----
namespace boost {
namespace crypt {

uisng return_type = boost::crypt::array<uint8_t, 16>;

inline auto sha1_file(const char* filepath) noexcept -> return_type;

inline auto sha1_file(const std::string& filepath) noexcept -> return_type;

inline auto sha1_file(std::string_view filepath) noexcept -> return_type;

} // namespace crypt
} // namespace boost
----

== Hashing Object

[#sha1_hasher]
Lastly, there is also the ability to create a sha1 hashing object and feed it bytes as the user parses them.
This class does not use any dynamic memory allocation.

[source, c++]
----
namespace boost {
namespace crypt {

class sha1_hasher
{
    uisng return_type = boost::crypt::array<uint8_t, 20>;

    void init();

    template <typename ByteType>
    BOOST_CRYPT_GPU_ENABLED inline auto process_byte(ByteType byte) noexcept -> hasher_state;

    template <typename ForwardIter>
    BOOST_CRYPT_GPU_ENABLED inline auto process_bytes(ForwardIter buffer, size_t byte_count) noexcept -> hasher_state;

    #ifdef BOOST_CRYPT_HAS_STRING_VIEW

    inline auto process_bytes(std::string_view str) noexcept -> hasher_state;

    inline auto process_bytes(std::u16string_view str) noexcept -> hasher_state;

    inline auto process_bytes(std::u32string_view str) noexcept -> hasher_state;

    inline auto process_bytes(std::wstring_view str) noexcept -> hasher_state;

    #endif // BOOST_CRYPT_HAS_STRING_VIEW

    #ifdef BOOST_CRYPT_HAS_SPAN

    template <typename T, boost::crypt::size_t extent>
    inline auto process_bytes(std::span<T, extent> data) noexcept -> hasher_state;

    #endif // BOOST_CRYPT_HAS_SPAN

    #ifdef BOOST_CRYPT_HAS_CUDA

    template <typename T, boost::crypt::size_t extent>
    BOOST_CRYPT_GPU_ENABLED inline auto process_bytes(cuda::std::span<T, extent> data) noexcept -> hasher_state;

    #endif // BOOST_CRYPT_HAS_CUDA

    inline auto get_digest() noexcept -> boost::crypt::array<boost::crypt::uint8_t, 20>;
};

} // namespace crypt
} // namespace boost
----
