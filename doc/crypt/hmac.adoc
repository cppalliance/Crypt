////
Copyright 2024 Matt Borland
Distributed under the Boost Software License, Version 1.0.
https://www.boost.org/LICENSE_1_0.txt
////

[#hmac]
:idprefix: hmac_

= HMAC

This library provides a robust implementation of HMAC (Hash-based Message Authentication Code) as specified in https://datatracker.ietf.org/doc/html/rfc2104[RFC 2104].
HMAC is a widely used mechanism for message authentication that combines a cryptographic hash function with a secret key to ensure data integrity and authenticity.

== Overview
HMAC is designed to provide a secure way to verify both the data integrity and the authenticity of a message. It uses a hash function (such as SHA-256, SHA-3/512, etc.) in combination with a secret key to generate a message authentication code (MAC). The MAC can then be used to verify that the message has not been altered and that it comes from an authenticated sender.

== Template Class Implementation
Our HMAC implementation is designed as a template class, allowing it to work seamlessly with any of our hashers. This flexibility means you can choose the most appropriate hashing algorithm for your specific use case without needing to modify the HMAC code itself. Here's how you might instantiate and use the HMAC class:

[source, c++]
----
boost::crypt::hmac<boost::crypt::sha512_hasher> hmac;
const auto state_1 {hmac.init("key", 3)};
BOOST_TEST(state_1 == boost::crypt::state::success);

const char* msg {"The quick brown fox jumps over the lazy dog"};
const auto state_2 {hmac.process_bytes(msg, std::strlen(msg))};
BOOST_TEST(state_2 == boost::crypt::state::success);

const auto res {hmac.get_digest()};
----


== Key Recovery and Reuse
One of the unique features of our HMAC implementation is the ability to recover the inner and outer keys after initialization.
This can be useful in scenarios where you need to compute HMACs for short messages repeatedly, as it allows you to avoid recalculating these keys each time.

Continuing from our above example:
[source, c++]
----
boost::crypt::hmac<boost::crypt::sha512_hasher> hmac;
const auto state_1 {hmac.init("key", 3)};
BOOST_TEST(state_1 == boost::crypt::state::success);

const char* msg {"The quick brown fox jumps over the lazy dog"};
const auto state_2 {hmac.process_bytes(msg, std::strlen(msg))};
BOOST_TEST(state_2 == boost::crypt::state::success);

const auto res {hmac.get_digest()};

const auto outer_key {hmac.get_outer_key()};
const auto inner_key {hmac.get_inner_key()};

// Do some stuff

boost::crypt::hmac<boost::crypt::sha512_hasher> hmac2(inner_key, outer_key);

const char* msg2 {"The quick brown fox jumps over the lazy dog"};
const auto state_3 {hmac2.process_bytes(msg, std::strlen(msg))};
BOOST_TEST(state_3 == boost::crypt::state::success);

const auto res2 {hmac2.get_digest()};
----

== Security Considerations
It is crucial to treat the inner and outer keys with the same level of security as the original secret key.
These keys should be stored securely and not exposed to unauthorized parties.
By providing this flexibility and functionality, our HMAC implementation aims to offer a secure, efficient, and versatile solution for message authentication in your applications.

== Reference

[source, c++]
----
namespace boost {
namespace crypt {

BOOST_CRYPT_EXPORT template <typename HasherType>
class hmac
{
public:

    static constexpr boost::crypt::size_t block_size_ {HasherType::block_size};
    using return_type = typename HasherType::return_type;
    using key_type = boost::crypt::array<boost::crypt::uint8_t, block_size_>;

    BOOST_CRYPT_GPU_ENABLED constexpr hmac() noexcept = default;

    template <typename ForwardIter>
    BOOST_CRYPT_GPU_ENABLED constexpr hmac(ForwardIter key, boost::crypt::size_t size) noexcept;

    template <typename Container>
    BOOST_CRYPT_GPU_ENABLED constexpr hmac(const Container& c) noexcept;

    BOOST_CRYPT_GPU_ENABLED constexpr hmac(const key_type& inner_key, const key_type& outer_key) noexcept;

    template <typename ForwardIter>
    BOOST_CRYPT_GPU_ENABLED constexpr auto init(ForwardIter key, boost::crypt::size_t size) noexcept -> state;

    template <typename Container>
    BOOST_CRYPT_GPU_ENABLED constexpr auto init(const Container& c) noexcept -> state;

    template <typename Container>
    BOOST_CRYPT_GPU_ENABLED constexpr auto init_from_keys(const Container& inner_key, const Container& outer_key) noexcept -> state;

    template <typename ForwardIter>
    BOOST_CRYPT_GPU_ENABLED constexpr auto process_bytes(ForwardIter data, boost::crypt::size_t size) noexcept -> state;

    template <typename Container>
    BOOST_CRYPT_GPU_ENABLED constexpr auto process_bytes(const Container& c) noexcept -> state;

    BOOST_CRYPT_GPU_ENABLED constexpr auto get_digest() noexcept -> return_type;

    BOOST_CRYPT_GPU_ENABLED constexpr auto get_outer_key() noexcept -> key_type;

    BOOST_CRYPT_GPU_ENABLED constexpr auto get_inner_key() noexcept -> key_type;

} //namespace crypt
} //namespace boost
----
